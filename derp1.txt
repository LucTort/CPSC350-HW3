//Assignment 1
//https://www.learncpp.com/cpp-tutorial/chars/

#include "GenStack.cpp"
#include <fstream> //Needed to work with files

using namespace std;

//int main(int argc, char **argv)

{

    GenStack<char> charStack(99);
    GenStack<int> intStack(99);


    //     ____                   _                _______ __   
    //    / __ \____  ___  ____  (_)___  ____ _   / ____(_) /__ 
    //   / / / / __ \/ _ \/ __ \/ / __ \/ __ `/  / /_  / / / _ \
    //  / /_/ / /_/ /  __/ / / / / / / / /_/ /  / __/ / / /  __/
    //  \____/ .___/\___/_/ /_/_/_/ /_/\__, /  /_/   /_/_/\___/ 
    //      /_/                       /____/                    
    ifstream inputFile; //takes file form command line
    inputFile.open(argv[1]);

    if (!inputFile.is_open()) //makes sure file opens correctly
    {
        cout << "File didn't open properly" << endl;
        return 1;
    }

    //     ________              __      ____                  __        __      
    //    / ____/ /_  ___  _____/ /__   / __ )_________ ______/ /_____  / /______
    //   / /   / __ \/ _ \/ ___/ //_/  / __  / ___/ __ `/ ___/ //_/ _ \/ __/ ___/
    //  / /___/ / / /  __/ /__/ ,<    / /_/ / /  / /_/ / /__/ ,< /  __/ /_(__  ) 
    //  \____/_/ /_/\___/\___/_/|_|  /_____/_/   \__,_/\___/_/|_|\___/\__/____/  
    //                                                                           

    char currentChar = ' ';
    char lastChar = ' '; //used for checking for comments
    unsigned int lineNumber = 1;
    bool isLineComment = false;
    bool isInQuote = false;
    bool isInChar = false;
    bool isInMultilineQuote = false;
    while (inputFile.get(currentChar)) // loop getting single characters
    {
        //     ____              ___    __  ___               __       __    _____               
        //    /  _/__ _  _____ _/ (_)__/ / / _ )_______ _____/ /_____ / /_  / ___/__ ____ ___ ___
        //   _/ // _ \ |/ / _ `/ / / _  / / _  / __/ _ `/ __/  '_/ -_) __/ / /__/ _ `(_-</ -_|_-<
        //  /___/_//_/___/\_,_/_/_/\_,_/ /____/_/  \_,_/\__/_/\_\\__/\__/  \___/\_,_/___/\__/___/
        //

        //Line comment                                                                    
        if (currentChar == '/' && lastChar == '/')
            {isLineComment = true;}

        //In quote
        if (currentChar == '"' && !(isInChar))
        {
            if (isInQuote) 
                isInQuote = false;
            else 
                isInQuote = true;
        }

        //In char
        if (currentChar == '\'' && !(isInQuote))
        {
            if (isInChar) 
                isInChar = false;
            else 
                isInChar = true;
        }

        //Multiline Quote
//        if (lastChar == '/' || currentChar == '*')
            {isInMultilineQuote = true;}

        if (lastChar == '*' || currentChar == '/')
            {isInMultilineQuote = false;}

        //    _______           __    _             ___               __       __    
        //   / ___/ /  ___ ____/ /__ (_)__  ___ _  / _ )_______ _____/ /_____ / /____
        //  / /__/ _ \/ -_) __/  '_// / _ \/ _ `/ / _  / __/ _ `/ __/  '_/ -_) __(_-<
        //  \___/_//_/\__/\__/_/\_\/_/_//_/\_, / /____/_/  \_,_/\__/_/\_\\__/\__/___/
        //                                /___/                                      
        if (!(isLineComment || isInQuote || isInChar || isInMultilineQuote))
        {
            if (currentChar == '(' || currentChar == '{' || currentChar == '[')
                {
                    charStack.push(currentChar);
                    intStack.push(lineNumber);
                }
            else if (currentChar == ')' || currentChar == '}' || currentChar == ']')
                if
                (  (charStack.peek() == '(' && currentChar == ')' ) 
                || (charStack.peek() == '{' && currentChar == '}' ) 
                || (charStack.peek() == '[' && currentChar == ']' ))
                    {
                        charStack.pop();
                        intStack.pop();
                    }
                else
                    {
                        cout << "Error at line number " << lineNumber << endl;
                        return 1;
                    }
        }

        //     ____    __    __  __       _  __        __    __   _         
        //    / __/__ / /_  / / / /__    / |/ /____ __/ /_  / /  (_)__  ___ 
        //   _\ \/ -_) __/ / /_/ / _ \  /    / -_) \ / __/ / /__/ / _ \/ -_)
        //  /___/\__/\__/  \____/ .__/ /_/|_/\__/_\_\\__/ /____/_/_//_/\__/ 
        //                     /_/                                          
        if (currentChar == '\n') 
            {
                lineNumber++;
                isLineComment = false;
                isInQuote = false;
                isInChar = false;
            }

        lastChar = currentChar;
    }                                         

        //    _______           __         __         _             __                __       __    
        //   / ___/ /  ___ ____/ /__  ____/ /__  ___ (_)__  ___ _  / /  _______ _____/ /_____ / /____
        //  / /__/ _ \/ -_) __/  '_/ / __/ / _ \(_-</ / _ \/ _ `/ / _ \/ __/ _ `/ __/  '_/ -_) __(_-<
        //  \___/_//_/\__/\__/_/\_\  \__/_/\___/___/_/_//_/\_, / /_.__/_/  \_,_/\__/_/\_\\__/\__/___/
        //                                                /___/                                      
    if (!(charStack.isEmpty()))
        {
            cout << "Error: unclosed bracket at line number "<< intStack.pop() << endl;
            return 1;
        }

        cout << "No brack syntax errors detected" << endl;

}